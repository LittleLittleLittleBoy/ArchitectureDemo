# 移动互联网应用端架构

## 引言

随着移动互联网时代的到来，移动技术也随之飞速发展。如今，APP已然成为绝大多数互联网企业用来获取用户的核心渠道。与此同时，伴随着业务量的高速增长，APP会面临多重挑战，如庞大的用户群体，高频高并发的业务等等，不断直面挑战的过程，同时也是其架构在不断演进和优化的过程，好的技术架构才能够持续支持伟大的商业梦想。

## 体系结构介绍

首先介绍一下软件架构，根据SEI的定义，软件架构是整个程序或系统的结构（Structure），包含程序的元素（Software Elements）和外部能看见的元素属性（Properties）和元素之间的关系（Relationship）。进一步探究可以得出，架构定义了结构，组件接口，组件之间的交流和依赖以及组件的职责。

​从整体上来看，架构可以分为四个部分，分别是业务架构、应用架构、数据架构和技术架构，这其中，业务架构是业务的细分，应用架构是业务的实现蓝图，数据架构是数据的应用目标而技术架构则是基础装备。这四个部分的架构是随着移动互联网应用规模的不断扩大而衍变产生的，每一个架构都有其特定的职责。业务架构，单独的分析各个业务之间可能存在的逻辑上的联系，尽量保证各个业务模块内部高聚合，模块之间低耦合。应用架构就相当于为具体的业务架构提供技术支持，数据架构是单独将应用的数据拆分出来，进行数据分析、数据清洗等用来为应用提供更好的服务保障。 技术架构相当于最底层的基础技术保障，提供诸如安全、通讯等基础服务。 一个业务庞杂的App通过这四个架构的相辅相成，为用户带来良好的使用体验。

​	在架构过程中，应该从一开始就对需要满足的质量属性保持高度的重视，通常在设计应用架构时需要考虑的质量属性包括可用性、性能、伸缩性、互操作性、安全性等等。其中大型移动互联网应用重点考虑的是性能、伸缩性和可用性。性能意味着应用要做到以用户为中心，提供快速的访问体验，衡量应用性能的主要参数有较短的响应时间，较大的并发处理能力，较高的吞吐量与稳定的性能参数。可用性代表移动互联网应用应该在任何时候都可以被正常访问，正常提供对外服务。伸缩性代表移动互联网应用可以在不改变原有架构设计的基础上，通过添加/减少硬件（服务器）的方式，适时地提高/降低系统的处理能力。

​	好的架构源于不断的衍变而不是设计，从来没有一个完美的架构能够一直支撑下去，架构是动态、实时变化的，在不断的变化过程中因为量变而发生质的变化，不同的阶段需要不同的架构。架构同样也是一个不断演进的过程，在我们这篇报告中，接下来将要介绍在各种应用背景下，为了应对各种不同的挑战而提出的各种移动互联网应用客户端架构。这其中包括MVC架构、MVP架构、MVVM架构等等。其中MVC架构是大部分移动互联网应用早期的选择，因为MVC架构“短平快”的开发优势，有助于帮助App快速占领市场，在MVC的体系架构中，Controller层负责整个APP中主要逻辑功能的实现；Model层则负责数据结构的描述以及数据持久化的功能；而View层作为展现层负责渲染整个APP的UI。分工清晰，简洁明了。然后，这种架构在开发的后期会由于其超高耦合性，造成Controller层庞大，而这也是一直被人们所诟病。最终的MVC都从Model-View-Controller走向了Massive-View-Controller的终点。这时就产生了MVP架构，将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。MVP架构相对于MVC架构，做到了模型与视图的完全分离，可以更高效的使用模型，同时可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。但MVP架构的代码还是不够优雅简洁，这时又产生了MVVM架构，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。在这里只是对这几种架构进行了一个简要的介绍，接下来，我们的报告中将会详细的对每一种架构的优缺点、适用场景等做一个完整的介绍与对比。
​
## MVC
### 组件

Model：从网络，数据库，文件，传感器，第三方等数据源读写数据；对外部的数据类型进行解析转换为APP内部数据交由上层处理；对数据进行临时存储、管理，协调上层数据请求；对数据进行逻辑操作并返回结果。

View：负责界面数据的展示，与用户进行交互，展示系统处理返回的结果。

Controller：一方面，根据Model的方法，对外提供方法并暴露接口；另一方面，对view请求进行转发并返回数据。

### 过程

view接受用户请求并将请求传递给controller，controller再调用某个model来处理用户的请求。在controller的控制下，将处理后的结果交给某个view进行格式化输出给用户。另外，View可以直接访问Model来进行数据的处理，这种操作可以通过观察者模式实现，即在view里设置listener，通过监听model里的逻辑操作来改变相应的数据展示。

### 与分层的比较

相比起分层只能逐级调用，在mvc中view可以不通过controller直接访问model；如果修改接口，分层模式中只会逐级影响自己的直接上层，在mvc中model会同时影响controller和view；在分层模式中，各模块之间由上层持有下层的引用，而mvc中各模块相互持有；分层模式的model主要是数据的封装，而mvc的model则包含了对数据的逻辑操作；分层模式的中间层logic负责业务逻辑，presenter负责界面展示，而mvc的controller既含有部分逻辑操作，也含有部分界面展示功能。

### 优点

耦合性低、重用性高、生命周期成本低、部署快、可维护性高、有利软件工程化管理

### 缺点

由于Android移动开发的特殊性，许多时候逻辑远没有界面复杂，大量复杂的view需要与model交互以获取与修改数据，带来了许多移动开发特有的问题。

一方面，activity的功能不单一。作为界面与数据逻辑沟通的桥梁，activity承担着极为复杂繁重的任务。而xml作为view层控制能力过弱，有许多功能，例如页面的动态化等，都是无法通过xml实现的，只能把代码写在activity中，造成了activity既是controller又是view的窘境。如果业务逻辑十分复杂，activity会变的十分臃肿、不易维护。

另一方面，在Android的MVC里，View可以直接访问Model，从而View里会包含Model的信息和一些业务逻辑。而且对同一个model有多个不同的相关View，即View是依赖于Model的，一旦model出现改变，多个与之相关的view都要随之更改，这就导致了model的修改极为困难。

### 总结

MVC模式的出现极大便利了GUI软件的开发，有利于开发成本的降低、代码质量的改善、生产效率的提高，使得软件开发的工程化管理更为便利。在重视图形界面与交互的移动端使用MVC进行开发，更是带来了许多便利。但是由于移动互联网开发的特殊性，Android中的MVC仍然存在许多不足，需要进一步的改善。

## MVP

### 组成

View :负责绘制UI元素、与用户进行交互

View interface : 由View实现的接口，View通过View
interface与Presenter进行交互，能有效降低耦合；

Model :负责存储、检索、操纵数据(也可使用Model interface降低耦合);

Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。

### 过程

声明一个由view来实现的接口，再将其注入到presenter中，然后将逻辑全部转移到presenter中，从而使view不再和model耦合，实现了控制逻辑和UI分离。从view接收到的请求传递给presenter，由presenter进行逻辑处理并转发至model，再将返回的结果交给view进行反馈。其中，Presenter可以不等待view的请求而主动调用view，从而实现异步交互。

### 与MVC的对比

在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变。

除此之外，controller与presenter也有不同。在MVC中，
View捕获到用户交互操作后会直接转发给Controller，由后者完成相应的UI逻辑。如果需要涉及业务功能的调用，Controller会直接调用Model。在完成UI处理之后，Controller会根据需要控制原View或者创建新的View对用户交互操作予以响应。而在MVP中，视图仅仅只是将用户的行为告知Presenter，而Presenter负责从视图中取得数据然后发送给模型。同时presenter也可以自主调用view的方法传递数据，从而使异步交互成为可能。

### 优点

模块职责划分明显，层次清晰，也有利于数据的隐藏和测试驱动的开发；降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Model；同时使View从特定的业务场景中脱离出来，只需提供接口，可以对业务完全无知，这样就可以使view组件高度可复用，进行界面开发时也可以专注于UI而无需考虑逻辑；由于对提供了view的抽象接口，Presenter也可以实现复用，一个Presenter可以用于多个View，而不需要更改Presenter的逻辑，提高了代码的灵活性。

### 缺点

Presenter中除了应用逻辑以外，还有大量的View-\>Model，Model-\>View的手动同步逻辑，造成Presenter比较笨重，维护起来比较困难。由于对视图的渲染放在了Presenter中，视图和Presenter的交互会过于频繁，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密，一旦视图需要变更，那么Presenter也需要随之变更。此外相对于MVC，额外的接口也会带来更大的工作量与学习成本。

### 小结

MVP模式在MVC模式的基础上，改善了模块间耦合的问题，提高了模块的独立性、可重用性、易修改性，给前后端的开发人员的独立工作带来了极大的便利。但是随着功能简化的activity变得轻便，逻辑与交互集中的presenter又开始变得臃肿与繁重。这些需要改善的问题呼唤着新的模式产生。

## MVVM

### **背景——MVC、MVP模式下可能存在的问题**

- MVC设计模式中，View负责展示，Model负责数据，Controller作为控制中心的同时，还承担了展示逻辑的职责——model提供的数据往往要经过封装才能交给视图。  Controller 往往会变得臃肿，难以复用。
- MVP设计模式中， view和presenter会互相持有引用，互相做回调 ，导致耦合度高；其次，在实际编码过程中，一旦视图需要变更，比如更改控件（比如用TextView 替换 EditText），那么Presenter也要相应的做变更了，这样做代码的可修改性差；再者，类似于MVC，复杂的业务会导致presenter过于臃肿 。

### MVVM概述

- #### MVVM组成部分

  MVVM（Model–view–view model）是一种软件架构模式，其组成部分有模型（Model）、视图（View）、视图模型（View Model）。

  ```
  - 模型（Model）指的是代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。
  - 视图（View）就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）
  - 视图模型（View Model）是暴露公共属性和命令的视图的抽象。
  ```

- #### 理论基础

  MVVM的设计思想是利用WPF（Windows Presentation Foundation，微软推出的基于Windows 的用户界面框架）下的数据绑定(Data Binding)、依赖属性(Dependency Property)、命令(Command)、路由事件(Routed Event)等新特性，打造了一个更加灵活高效的架构。 

  - 数据绑定(Data Binding)	

  > MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离，使MVVM设计模式下的应用程序具有层次性。
  >
  > 因此，应用程序的层次可以在多个工作流中进行开发以提高生产力。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。用户体验（UX）开发人员不需要编写GUI代码，他们可以使用框架标记语言（如XAML），使UI与应用程序开发人员编写和维护的视图模型的数据绑定起来。
  >
  > 即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。

  在数据绑定出现以前，我们在实现界面时，不可避免的编写各种更新 View 属性的 setter：比如

  `setText()，setVisibility()，setEnabled ()` 等等。这些代码数量越多，越容易滋生 bug，代码的可修改性也会下降。使用数据绑定后，视图的数据直接与视图模型进行绑定，可以避免大量书写这些代码。

  比如，如下是Android开发中一段Java代码，其目的是查找视图的一个文本元素，并设定该文本内容的属性：

  ```
  numText=(TextView)rootView.findViewById(R.id.mvp_numb);
  numText.setText(String.valueOf(num));
  ```

  使用数据绑定的方法，可以在布局文件中以一种简洁的形式代替，如下：

  ```
  android:text="@{sc.number}" 
  ```

  其中sc是MVVM中视图模型（View Model）的变量名，number是sc的一个成员变量，这样元素的属性就与视图模型绑定在一起了。

### 代码实践

1. 对于Android开发的MVC架构的计数器Demo，改用MVVM架构。

   实践过程：

   （1）修改代码或者配置文件，设定 View Model 和 View 的映射关系。 

   ​	在gradle文件中添加数据绑定的代码声明，使得之后构建系统会对数据绑定启用附加处理。 

   ```
   dataBinding{ enabled = true }
   ```

   （2）修改layout.fragment_mvvmdemo.xml文件 
 	使用数据绑定之后，无需再通过findViewById或者注解框架去设置数据，布局文件就不再用于单纯地展示界面元素，还需要定义界面元素用到的变量。它的根节点由 ViewGroup变成了 layout，并且新增了一个节点 data。Data节点用来声明需要与视图绑定的视图模型。

   ```
   <layout xmlns:android="http://schemas.android.com/apk/res/android">
   
       <data>
           <variable name="sc"
               type="cn.edu.nju.candleflame.architecturedemo.mvvm.viewmodel.SimpleCal" />
       </data>
       
       ...
       
       <EditText
               android:id="@+id/mvvm_number"
               ...
               android:text="@={sc.number}"/>
   
   ...
   
   ```

   在布局中通过 “@{具体变量或者对象的属性值}” 直接把Java中定义的属性值赋值给UI元素中的某个属性.

   （3）编写MainActivity 

   ​	数据绑定库通过自动生成**绑定类**为我们完成数据绑定的工作。要获取布局的相应绑定类的实例，就要用到库提供的辅助方法--Activity 对应使用 `DataBindingUtil.setContentView()` ，Fragment使用`DataBindingUtil.inflate()`

   ```
   	public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                Bundle savedInstanceState) {
           FragmentMvvmdemoBinding binding = DataBindingUtil.inflate(inflater,
                   R.layout.fragment_mvvmdemo, container, false);
           simpleCal=new SimpleCal();
           binding.setSc(simpleCal);
          
   		...
   		
           return binding.getRoot();
       }
   ```

   （4）定义视图模型和模型

   ​	此步骤较为简单，由于篇幅原因，故省略。可以直接参考代码。

2. 对于该MVVM架构的计数器，进行功能的扩展：使展示数字的文本框可以被编辑，并且根据编辑后的数字重新判断新的年份是平年还是闰年。

   实践过程：

   （1）修改xml文件：

   ```
   <EditText
   
   	... 
   	
     	android:text="@={sc.number}"/>
   ```

   这里由原项目代码`android:text="@{sc.number}"`修改而来。"="符号所起的作用是完成数据的双向绑定，这意味着这一个EditText的文本属性发生的更改，能够触发视图模型里的属性也随之更改。 

   （2）修改模型：对CounterModel稍作修改，修改原因见3。 

   ```
   public class CounterModel {
   	
   	...
   	
       public void update(SimpleCal sc) {
           int i = Integer.parseInt(sc.number) ;
           setYear(i);
       }
   }
   ```

   （3）修改视图模型：修改`setNumber()`的参数类型，并引入`update()`。主要是由于视图输入的数字是String类型，因此必须修改参数类型来接收数据。

   ```
       @Bindable
       public void setNumber(String number) {
           ...
           counterModel.update(this);	//新添line
           ...
       }
   ```

### 对MVVM模式优缺点的一些讨论

1. 由于展示逻辑被抽取到了视图模型中，所以 视图的代码将会变得非常轻量级。

2. 在可复用性方面，一个视图模型可以复用到多个视图中，同样的一份数据，可以用于不同的界面展示。 

3. 在可修改性方面，如果一个model 封装了大量业务逻辑，那么改变它可能会比较困难，并且存在一定的风险。在这种场景下，View Model 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。  

4. MVVM模式中，View Model只负责处理和提供数据，不涉及界面。 如果是MVP模式，遇到需要更改界面的场景，就可能需要改变接口。

5. MVVM具有良好的可测试性。

   通常来说, 要进行界面测试比较困难,  比如在MVC架构中，我们不得不实例化一个完整的 Controller     以及伴随的 View , 然后去测试View 中的值。现在在MVVM的架构下，展示逻辑移入了View Model，表示逻辑与实际表示分离，然后对View Model的展示逻辑进行测试。

6. 数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。 看到界面出现异常，有可能是 View 的代码有问题，也可能是 Model 的代码有问题 。

7. 一个大的模块中，model也会很大，当时长期持有时，不释放内存，就造成了更多的内存花销。

8. MVVM的创造者John Gossman本人对这种模式的批评指出，实现MVVM的开销对于简单的UI操作是“过度的”。他说，对于更大的应用来说，推广ViewModel变得更加困难。而且，他说明了非常大的应用程序中的数据绑定会导致相当大的内存消耗。

## FRP

### 内容总结

在课程中向大家介绍了FRP相关的内容，主要是FRP与传统event callback的对比和FRP的使用场景，利用具体的例子（Flicker，拖动，酒店价格计算）描绘了FRP的使用，简单介绍了会使用到的流操作。
FRP(Functional Reactive Programming)作为一种编程风格或范式，主要和传统的event callback的方式产生了比较。对于高度复杂的业务逻辑，基于控制流来编写代码可能会非常的复杂且难以维护，而基于数据流就成为了一个新的角度，能产生意想不到的惊喜结果。

主要通过三个例子介绍了FRP，第一个是Flicker图片搜索的例子，主要体现的是响应式特性，后续需求变更中体现了FRP事件流操作面对需求时的灵活性。第二个拖动图标的例子则真切的体现出了流操作在特定场景下优于事件回调机制的地方，第三个酒店价格计算的例子则介绍了FRP在实际高度复杂的场景中的应用。此后就流模型的基本操作介绍了map, merge等内容。

### 内容补充

限于课程时间，有一些额外的内容没有讲，在此补充。

关于FRP和传统callback方式的优缺点对比讲的并不清楚，只说了对于那些适合流式建模的现实需求，用FRP可以展现优势。

更详细的说，在FRP的编程模型里，基本信号可以在不做任何修改的情况下被转换或者组合成新的复杂信号，而新的复杂信号又可以在不做任何修改的情况下被转换或者组合成更复杂的信号，就像乐高积木的搭建，这个过程可以一直进行下去，直到构建出足够复杂的信号以满足系统的需求。这正是程序员梦寐以求的组合能力(Composability)。

程序中注册的事件回调处理函数的返回值一般都是void或者是一个表示执行状态的状态码。不太可能让返回值可以随意使用各种数据类型，这是因为一个事件驱动框架要通用地处理各种callback，就只能让它的返回值类型足够通用，void便是首选。因此，回调与回调之间是无法直接传递类型丰富的数据的，它们只能通过修改应用程序的共享状态来间接地通讯，这迫使程序员不得不把应用逻辑分割得支离破碎，从而丧失了核心的组合能力！这便是callback风格程序的最大问题。

Callback模型关注控制流，但它对控制流的描述不具有很好的组合性。FRP模型换了一个视角，关注数据流，且数据流的组合能力极佳，使得代码更接近于只描述做什么(what)的声明式(declarative)代码，而不是描述怎么做(how)的命令式(imperative)代码，相当简洁和直观，更符合人的自然思维。

### 内容反思

课上介绍的内容还是十分充实的，有丰富的例子，和一般情况下event callback的对比也能让同学们有共鸣感，不至于觉得FRP和自己没有关系。而且FRP这样一个新鲜的机制也不会让同学们觉得无聊，所以课上介绍的内容还是不错的。

但是最需要改的是FRP这一块的课后作业。FRP虽然有优势，但是并非绝对优于事件回调机制，某些场景并不适用FRP，所以课后作业的需求设计应该要足够适合FRP，让同学们在实践中体会FRP的操作方式与event callback的不一样。

围绕我们的计数器，我觉得比较好的一个作业需求是：修改计数器逻辑，200ms内连按两次ADD键才将数字加一，连按两次SUB键才将数字减一。这样的话，在做这可课后作业的时候，最起码要将事件流中的buffer, map, filter操作体现出来，这样才能让同学们真正用FRP的写法来实现一个需求，而不是单纯的修改某处的逻辑代码。

![](https://raw.githubusercontent.com/candleflame/picGo/master/pic/20180630095523.png)

## Dagger介绍

当我们使用上面所说的各种架构模式来帮助我们分解逻辑简化代码的时候，仿佛一切都变的简单起来，界面只用关注界面元素的布局，数据只需关注数据的内容，控制只需要将界面和数据之间对应关系搞清楚就好，一个团队可以很容易的合作编写代码。代码编写之后却会出现一个麻烦的事情：不同人的代码如何组合在一起？

无论是采用工厂类还是初始化的时候构建，复杂的对象之间的引用让再熟练的工程师也变得头疼起来，如何管理对象之间的关系以及对象的创建和回收变得极其重要。为了防止循环构建和引用传递的复杂性以及对象生命周期管理的问题、最小化代码合并所做的额外的工作，一个依赖注入框架必不可少。

依赖注入是实现控制反转的方式，通过控制反转，将成员对象的生命周期从调用方独立出来。此时调用方可以通过依赖来获取对象实例，并且加以使用，而不用关心对象怎么来的，使用完之后是否销毁等操作。基于这个思想，实现依赖注入的框架有很多，比如Spring,Guice等等，但是他们却因为配置文件复杂或者运行时对性能要求极高而不能在移动应用开发中加以使用，而基于编译时运行的Dagger框架完美解决了这个情况。

Dagger2是一个基于JSR-330标准的依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。它前期是基于Square开发的Dagger框架，相比较Dagger1,他取消了反射机制在图的验证、配置和预先设置都在编译的时候执行（Dagger1还是使用到了一部分反射，如图的这块)，牺牲少量灵活性的基础上，使用Builder模式，Factory模式变得更加容易调试和可跟踪，有更好的性能。Dagger2目前成为客户端代码使用依赖注入的主流选择。

Dagger2中主要是用两个注解来进行定位：@Component和@Inject来定义依赖关系，可将注解配置到方法或者成员变量来说明如何使用。这点在课上已经通过代码来进行了讲解，并且给出了使用和未使用框架的代码对比。这两个注解是对Dagger2框架的最基本的使用，Dagger2框架还提供了其他的注解来实现更多的功能。下面对Dagger2框架的其他功能进行详解。

* @Provides 和 @Module

	我们在使用第三方插件的时候，我们需要在代码中引入相关类，但是第三方封装好的实现，我们并不能在其源码上进行修改添加@Component注解,这是我们需要这两个组件来辅助我们创建对象。使用@Module描述类来声明模块，在模块内部使用@Provides声明方法来提供对象，此时被声明的方法中需要返回相关类的实例。@Module在使用时，需要在@Component的注解中添加module这个参数来绑定Component和Module的对应关系

* SubComponent

	面向对象的特点之一便是继承，我们可以用@SubComponent中声明依赖的Component来进行扩展重用。但是笔者认为组合优于继承，不建议大家使用

* @Singleton

	顾名思义，@Singleton注解是声明一个单例，可以保证对象在整个运行期间是保证唯一的：比如数据库连接类，网络控制服务类。使用的时候用 @Singleton 标注在目标单例上，然后用 @Singleton 标注在 Component 对象上。

* @Scope

	Scope 的字面意思是作用域，也就是表达一种能力的范围。@Scope用来对对象的生命周期来进行限制，可以用@Scope来自定义注解，在声明注解的时候加上生命周期的现实。@Singleton就是@Scope注解的一个特殊实例,能够起作用是因为它被 @Scope 注解。
	
* @Qualifiers 和 @Name

	在我们的Module中的@Provides 提供的依赖是由返回值决定的，但是对于同一种类型不同实例，我们就需要用@Name来给类型的不同实例提供别名。使用Name之后我们调用的时候调用类型的时候，如果有多个实例，会根据Name的不同属性来确定具体返回哪一个对象。而使用@Qualifier可以来自定义注解，用自定义注解可以将Name的属性值独立出来统一管理，避免在代码中编写过多的Name的属性值，难以管理，修改。
	
Dagger2框架在2012年诞生之后，伴随着Google推广的MVP+Dagger2的架构组合，Dagger2开始被广大程序员所青睐。尤其是在近两年，Android应用的结构越来越复杂、功能越来越多，模块开发已经成为不可阻挡的趋势，使用Dagger来松耦合模块也被更多的使用。Dagger2在Google公司的努力下，更加适配Android系统的Dagger Android也出现了，让依赖注入在Android开发生态中扮演着不可缺少的一环。相信在未来，Dagger会被越来越多的公司和开发者来使用。


## App架构演进
### 总结
万丈高楼平地起。在架构演进的过程中，小到核心模块代码，大到核心架构，都会不断演进，这个过程值得我们去深入学习和思考。下面以两个亿万级APP为例介绍大型项目构是如何进行优化和演进的。
### 微信
一个典型的Android应用在从小到大的成长过程中的“踩坑”与“填坑”的历史。
#### 1.拓荒
微信1.0 for Android的测试版本于2011年1月发布。这是微信Android客户端的第一个版本，软件架构采用早期标准的Android系统应用设计。
![图片11.png](https://upload-images.jianshu.io/upload_images/6223300-f83c3447a6098c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 2.成长
微信的快速增长，从2.0版本开始第一次爆发。从语音版，到附近的人、漂流瓶，再到摇一摇。3.0之后的每一个小版本都处在一到两周的高速迭代过程中。
#### 3.变革
代码、内存、apk大小都在膨胀，这其中，内存对消息收发的影响很关键。如何解决？微信选择的，是轻重分离的思路。通过在微信3.5版本时候做的架构重构，实现了不受功能增长、系统缺陷影响的稳定推送方案。
![图片12.png](https://upload-images.jianshu.io/upload_images/6223300-bf930da618f259ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 4.进化
微信在高速发展过程当中，到5.0的时候已经有很多功能，而其中一些功能，随着用户群体、产品设计等因素变化，用户使用的频率在改变。之前试错的一些功能，也大量存留在微信版本中。这些不常使用的功能不应该始终占用程序资源，从架构上进行纵向分离，保证主要场景的体验，是这一时期的主要设计思路。
![图片13.png](https://upload-images.jianshu.io/upload_images/6223300-24314290efb8a9e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 5.开放
进入到2015年后，微信在软件架构上逐渐趋于平稳。内部也放弃了沿用许久的ant + eclipse，全面转向gradle + Android Studio的分布式构建思想。通过内部开源，微信内的公共组件已经可以通过maven在不同的开发团队中共享并随时使用。
### 淘宝
阿里巴巴打造的不是一个软件系统平台，而是一个电子商务操作系统。这样的电商操作系统，支撑了过去10年的快速发展。同样，阿里在移动端也在重新思考如何继续升级，如何在手机APP中完成生态建设。
#### 1.发展阶段
从2009年开始，DAU从100万增长到超过1亿，面临的问题、包括研发支撑所需要解决的事情各不相同。在用户量和业务复杂度的线性递增下，架构也进行了相应的演进。如下图所示，具体可以分为四个阶段：
![图片14.png](https://upload-images.jianshu.io/upload_images/6223300-9656f6bce308dc63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 2.API网关
随着应用数量的增多，每个应用分别暴露的API出口很多，修改的话逻辑很复杂，这时候应该引入一个统一的网关。
![图片15.png](https://upload-images.jianshu.io/upload_images/6223300-f4a7962f932042fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 3.WebApp
下图是现在手机淘宝上关于HTML5的整体框架图。手机淘宝上的方案大致分为两部分，中间那一部分是手机淘宝自己开发的HTML5的运行容器，它负责在上面跑各种各样的WebApp，在线上有一个统一发布管理系统。
![图片16.png](https://upload-images.jianshu.io/upload_images/6223300-6bc2bee3fec67825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 4.PackageApp
跟之前最大的区别就是让用户感知不到前面同步下载的过程，大概的做法是：把HTML5以及WebApp在发版之前先做一些预知放到客户端里面，前面会做两件事情，首先按照原来的逻辑运行，其次就是在右侧的蓝图里面。
![图片17.png](https://upload-images.jianshu.io/upload_images/6223300-80516ce61c7dc1d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
从上述对两个典型App架构演进的总结，可以看出，所有大型项目的架构和代码，都是这么一步一步的根据实际的业务场景，和发展情况发展演变而来的，在不同的阶段，会使用的不同的技术，不同的架构来解决实际的问题，因此，高大上的项目技术架构和开发设计实现不是一蹴而就的。
### 补充
近几年，业内一些知名度较高的应用都分享了各自的应用架构，微信和淘宝只是其中之二。做架构之前，要想清楚这样设计的目的是什么，通过架构设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合，做到基本符合迪米特、依赖倒置、里氏替换、接口隔离等原则。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌为了设计而设计，为了架构而架构。
### 分享课堂
缺少从微信和淘宝的例子中以小见大，总结出如今成功App的演进规律、新开发的技术和遵循的法则。架构是非常值得分享和讨论的，好的技术架构能够持续支持伟大的商业梦想。但是无论什么优秀的可扩展性好的技术架构，都不能脱离于业务而存在，最终都会随着业务的不断发展，而同时其架构也在进行不同程度的演进与优化。一个好的架构首先是必须是能解决公司遇到的现实技术问题和符合满足公司目前架构技术现状，其次能带来技术性的革新从而引领业务的发展。

## 整体总结
### 应用架构
软件架构（SEI）：是整个程序或系统的结构（Structure），包含程序的元素（Software Elements）和外部能看见的元素属性（Properties）和元素之间的关系（Relationship）。
业务架构是业务的细分；应用架构是业务的实现蓝图；数据架构是数据的应用目标；技术架构是基础装备。
![图片 1.png](https://upload-images.jianshu.io/upload_images/6223300-c60dad15571cc907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
架构是基于产品和技术所达成的一种共识。这种共识便是在产品规划、设计、开发阶段一些重要方面所作出的决策的集合。这些决策是我们项目各个角色成员通过计划会、评审会、迭代会等达成的共识，并最终表现在我们的产品上。好的架构决定好的产品。
### MVC/MVP/MVVM/FRP
架构设计的目的：通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。
#### MVC -> MVP -> MVVM
MVC -> MVP -> MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。
![图片 2.png](https://upload-images.jianshu.io/upload_images/6223300-92028cbff469f9be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
##### 相同点
如果把这三者放在一起比较，先说一下三者的共同点，也就是Model和View：
Model：数据对象，同时，提供本应用外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。
View：UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。
##### 不同点
三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知。
- Controller：Controller接收View的操作事件，根据事件不同，或者调用Model的接口进行数据操作，或者进行View的跳转，从而也意味着一个Controller可以对应多个View。Controller对View的实现不太关心，只会被动地接收，Model的数据变更不通过Controller直接通知View，通常View采用观察者模式监听Model的变化。
- Presenter：Presenter与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。一个Presenter只对应于一个View。根据Presenter和View对逻辑代码分担的程度不同，这种模式又有两种情况：Passive View和Supervisor Controller。
- ViewModel：注意这里的“Model”指的是View的Model，跟MVVM中的一个Model不是一回事。所谓View的Model就是包含View的一些数据属性和操作的这么一个东东，这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。

#### FRP
函数式反应式编程(FRP) 是一种采用函数式编程的基础部件（如 map、reduce、filter 等）进行反应式编程（异步数据流编程）的编程范式。FRP 被用于GUI、机器人和音乐方面的编程，旨在通过明确时间模型来简化这些问题。
![图片 3.png](https://upload-images.jianshu.io/upload_images/6223300-ac5dc7d5b220a233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
FRP提高了抽象的层次，因此你可以专注于业务逻辑里面事件间的相互依赖，而不需要关心一大堆实现的细节。用FRP将会使代码变得更加简洁。
FRP的优势在富“UI事件和数据事件交互”的现代Web、移动应用得到了证明。10年前，Web页面的交互基本上就是提交一个大表单到后端，然后在前端执行简单的渲染。应用逐渐变得更加实时：修改单个表单域能够自动触发保存到后台，内容会根据个人的“喜好”匹配到相关用户等等。
现今的应用需要通过丰富多样的实时事件来提供高水平的用户体验，而FRP可以很好解决。

### 依赖注入
当一个类的实例需要另一个类的实例协助时，通常有调用者来创建被调用者的实例。然而采用依赖注入（Dependency Injection）的方式，创建被调用者的工作不再由调用者来完成，因此叫控制反转（Inversion of Control），创建被调用者的实例的工作由IOC容器来完成，然后注入调用者，因此也称为依赖注入。
控制反转的基础是面向接口编程，但是即使是做到了面向接口编程也未必能避免硬初始化（Hard Inition）问题。硬初始化带来诸多问题，使得代码移植或复用变得困难，不能灵活的应对单元测试。使用依赖注入能方便的消除硬初始化。
使用依赖注入的好处：
1.依赖的注入和配置独立于组件之外，注入的对象在一个独立、不耦合的地方初始化，这样在改变注入对象时，我们只需要修改对象的实现方法，而不用大改代码库。
2.依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。
3.App中的组件不需要知道有关实例创建和生命周期的任何事情，这些由我们的依赖注入框架管理的。

### App架构演进
![图片 4.png](https://upload-images.jianshu.io/upload_images/6223300-f411e684d2c7f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上面是一些安全体系系统，如数据安全体系、应用安全体系、前端安全体系等。
中间是业务运营服务系统，如会员服务、商品服务、店铺服务、交易服务等。
还有共享业务，如分布式数据层、数据分析服务、配置服务、数据搜索服务等。
最下面呢，是中间件服务，如MQS即队列服务，OCS即缓存服务等。
一个大型服务系统都是从小一步一步走过来的，在每个阶段，找到对应该阶段网站架构所面临的问题，然后在不断解决这些问题，在这个过程中整个架构会一直演进。
架构是非常值得分享和讨论的，好的技术架构能够持续支持伟大的商业梦想。但是无论什么优秀的可扩展性好的技术架构，都不能脱离于业务而存在，最终都会随着业务的不断发展，而同时其架构也在进行不同程度的演进与优化。一个好的架构首先是必须是能解决公司遇到的现实技术问题和符合满足公司目前架构技术现状，其次能带来技术性的革新从而引领业务的发展。

### 总结与反思
本次报告围绕着移动应用的发展描述了应用架构的特点，MVC、MVP等设计模式的演变，架构开发用到的方法、编程原则和一些大型App的架构演进史。以小见大，见微知著，好的架构决定好的产品，而大型架构也是遵循着“面向接口编程”，“单一职责”，“高内聚低耦合”等原则构建模块，一砖一瓦堆砌成的。对架构的学习和思考告诉我们不论工作、生活中都要学着将复杂的事情分离，减少每项任务间的交叉，要不断的更新对自己的认识，做出更加合适的决策。
反思：在多人报告中缺乏每个人内容上的承接和整体的把握；在内容上可以有更加丰富的扩展而不是概念的陈述。




